/* Code generated by IfcQuery EXPRESS generator, www.ifcquery.com */

#include <sstream>
#include <limits>
#include <map>
#include "ifcpp/reader/ReaderUtil.h"
#include "ifcpp/writer/WriterUtil.h"
#include "ifcpp/model/BasicTypes.h"
#include "ifcpp/model/BuildingException.h"
#include "ifcpp/IFC4/include/IfcFacilityPartTypeSelect.h"
#include "ifcpp/IFC4/include/IfcMarinePartTypeEnum.h"

// TYPE IfcMarinePartTypeEnum = ENUMERATION OF	(CREST	,MANUFACTURING	,LOWWATERLINE	,CORE	,WATERFIELD	,CILL_LEVEL	,BERTHINGSTRUCTURE	,COPELEVEL	,CHAMBER	,STORAGE	,APPROACHCHANNEL	,VEHICLESERVICING	,SHIPTRANSFER	,GATEHEAD	,GUDINGSTRUCTURE	,BELOWWATERLINE	,WEATHERSIDE	,LANDFIELD	,PROTECTION	,LEEWARDSIDE	,ABOVEWATERLINE	,ANCHORAGE	,NAVIGATIONALAREA	,HIGHWATERLINE	,USERDEFINED	,NOTDEFINED);
shared_ptr<BuildingObject> IfcMarinePartTypeEnum::getDeepCopy( BuildingCopyOptions& options )
{
	shared_ptr<IfcMarinePartTypeEnum> copy_self( new IfcMarinePartTypeEnum() );
	copy_self->m_enum = m_enum;
	return copy_self;
}
void IfcMarinePartTypeEnum::getStepParameter( std::stringstream& stream, bool is_select_type ) const
{
	if( is_select_type ) { stream << "IFCMARINEPARTTYPEENUM("; }
	switch( m_enum )
	{
		case ENUM_CREST:	stream << ".CREST."; break;
		case ENUM_MANUFACTURING:	stream << ".MANUFACTURING."; break;
		case ENUM_LOWWATERLINE:	stream << ".LOWWATERLINE."; break;
		case ENUM_CORE:	stream << ".CORE."; break;
		case ENUM_WATERFIELD:	stream << ".WATERFIELD."; break;
		case ENUM_CILL_LEVEL:	stream << ".CILL_LEVEL."; break;
		case ENUM_BERTHINGSTRUCTURE:	stream << ".BERTHINGSTRUCTURE."; break;
		case ENUM_COPELEVEL:	stream << ".COPELEVEL."; break;
		case ENUM_CHAMBER:	stream << ".CHAMBER."; break;
		case ENUM_STORAGE:	stream << ".STORAGE."; break;
		case ENUM_APPROACHCHANNEL:	stream << ".APPROACHCHANNEL."; break;
		case ENUM_VEHICLESERVICING:	stream << ".VEHICLESERVICING."; break;
		case ENUM_SHIPTRANSFER:	stream << ".SHIPTRANSFER."; break;
		case ENUM_GATEHEAD:	stream << ".GATEHEAD."; break;
		case ENUM_GUDINGSTRUCTURE:	stream << ".GUDINGSTRUCTURE."; break;
		case ENUM_BELOWWATERLINE:	stream << ".BELOWWATERLINE."; break;
		case ENUM_WEATHERSIDE:	stream << ".WEATHERSIDE."; break;
		case ENUM_LANDFIELD:	stream << ".LANDFIELD."; break;
		case ENUM_PROTECTION:	stream << ".PROTECTION."; break;
		case ENUM_LEEWARDSIDE:	stream << ".LEEWARDSIDE."; break;
		case ENUM_ABOVEWATERLINE:	stream << ".ABOVEWATERLINE."; break;
		case ENUM_ANCHORAGE:	stream << ".ANCHORAGE."; break;
		case ENUM_NAVIGATIONALAREA:	stream << ".NAVIGATIONALAREA."; break;
		case ENUM_HIGHWATERLINE:	stream << ".HIGHWATERLINE."; break;
		case ENUM_USERDEFINED:	stream << ".USERDEFINED."; break;
		case ENUM_NOTDEFINED:	stream << ".NOTDEFINED."; break;
	}
	if( is_select_type ) { stream << ")"; }
}
const std::wstring IfcMarinePartTypeEnum::toString() const
{
	switch( m_enum ) 
	{
		case ENUM_CREST:	return L"CREST";
		case ENUM_MANUFACTURING:	return L"MANUFACTURING";
		case ENUM_LOWWATERLINE:	return L"LOWWATERLINE";
		case ENUM_CORE:	return L"CORE";
		case ENUM_WATERFIELD:	return L"WATERFIELD";
		case ENUM_CILL_LEVEL:	return L"CILL_LEVEL";
		case ENUM_BERTHINGSTRUCTURE:	return L"BERTHINGSTRUCTURE";
		case ENUM_COPELEVEL:	return L"COPELEVEL";
		case ENUM_CHAMBER:	return L"CHAMBER";
		case ENUM_STORAGE:	return L"STORAGE";
		case ENUM_APPROACHCHANNEL:	return L"APPROACHCHANNEL";
		case ENUM_VEHICLESERVICING:	return L"VEHICLESERVICING";
		case ENUM_SHIPTRANSFER:	return L"SHIPTRANSFER";
		case ENUM_GATEHEAD:	return L"GATEHEAD";
		case ENUM_GUDINGSTRUCTURE:	return L"GUDINGSTRUCTURE";
		case ENUM_BELOWWATERLINE:	return L"BELOWWATERLINE";
		case ENUM_WEATHERSIDE:	return L"WEATHERSIDE";
		case ENUM_LANDFIELD:	return L"LANDFIELD";
		case ENUM_PROTECTION:	return L"PROTECTION";
		case ENUM_LEEWARDSIDE:	return L"LEEWARDSIDE";
		case ENUM_ABOVEWATERLINE:	return L"ABOVEWATERLINE";
		case ENUM_ANCHORAGE:	return L"ANCHORAGE";
		case ENUM_NAVIGATIONALAREA:	return L"NAVIGATIONALAREA";
		case ENUM_HIGHWATERLINE:	return L"HIGHWATERLINE";
		case ENUM_USERDEFINED:	return L"USERDEFINED";
		case ENUM_NOTDEFINED:	return L"NOTDEFINED";
	}
	return L"";
}
shared_ptr<IfcMarinePartTypeEnum> IfcMarinePartTypeEnum::createObjectFromSTEP( const std::wstring& arg, const std::map<int,shared_ptr<BuildingEntity> >& map )
{
	if( arg.compare( L"$" ) == 0 ) { return shared_ptr<IfcMarinePartTypeEnum>(); }
	if( arg.compare( L"*" ) == 0 ) { return shared_ptr<IfcMarinePartTypeEnum>(); }
	shared_ptr<IfcMarinePartTypeEnum> type_object( new IfcMarinePartTypeEnum() );
	if( std_iequal( arg, L".CREST." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_CREST;
	}
	else if( std_iequal( arg, L".MANUFACTURING." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_MANUFACTURING;
	}
	else if( std_iequal( arg, L".LOWWATERLINE." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_LOWWATERLINE;
	}
	else if( std_iequal( arg, L".CORE." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_CORE;
	}
	else if( std_iequal( arg, L".WATERFIELD." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_WATERFIELD;
	}
	else if( std_iequal( arg, L".CILL_LEVEL." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_CILL_LEVEL;
	}
	else if( std_iequal( arg, L".BERTHINGSTRUCTURE." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_BERTHINGSTRUCTURE;
	}
	else if( std_iequal( arg, L".COPELEVEL." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_COPELEVEL;
	}
	else if( std_iequal( arg, L".CHAMBER." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_CHAMBER;
	}
	else if( std_iequal( arg, L".STORAGE." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_STORAGE;
	}
	else if( std_iequal( arg, L".APPROACHCHANNEL." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_APPROACHCHANNEL;
	}
	else if( std_iequal( arg, L".VEHICLESERVICING." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_VEHICLESERVICING;
	}
	else if( std_iequal( arg, L".SHIPTRANSFER." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_SHIPTRANSFER;
	}
	else if( std_iequal( arg, L".GATEHEAD." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_GATEHEAD;
	}
	else if( std_iequal( arg, L".GUDINGSTRUCTURE." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_GUDINGSTRUCTURE;
	}
	else if( std_iequal( arg, L".BELOWWATERLINE." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_BELOWWATERLINE;
	}
	else if( std_iequal( arg, L".WEATHERSIDE." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_WEATHERSIDE;
	}
	else if( std_iequal( arg, L".LANDFIELD." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_LANDFIELD;
	}
	else if( std_iequal( arg, L".PROTECTION." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_PROTECTION;
	}
	else if( std_iequal( arg, L".LEEWARDSIDE." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_LEEWARDSIDE;
	}
	else if( std_iequal( arg, L".ABOVEWATERLINE." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_ABOVEWATERLINE;
	}
	else if( std_iequal( arg, L".ANCHORAGE." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_ANCHORAGE;
	}
	else if( std_iequal( arg, L".NAVIGATIONALAREA." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_NAVIGATIONALAREA;
	}
	else if( std_iequal( arg, L".HIGHWATERLINE." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_HIGHWATERLINE;
	}
	else if( std_iequal( arg, L".USERDEFINED." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_USERDEFINED;
	}
	else if( std_iequal( arg, L".NOTDEFINED." ) )
	{
		type_object->m_enum = IfcMarinePartTypeEnum::ENUM_NOTDEFINED;
	}
	return type_object;
}
